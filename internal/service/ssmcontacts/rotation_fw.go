// Code generated by tools/tfsdk2fw/main.go. Manual editing is required.

package ssmcontacts

import (
	"context"

	"github.com/aws/aws-sdk-go-v2/service/ssmcontacts"
	awstypes "github.com/aws/aws-sdk-go-v2/service/ssmcontacts/types"
	"github.com/aws/aws-sdk-go/aws"
	"github.com/hashicorp/terraform-plugin-framework-validators/listvalidator"
	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/path"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/listplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/schema/validator"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/hashicorp/terraform-plugin-log/tflog"
	"github.com/hashicorp/terraform-provider-aws/internal/create"
	"github.com/hashicorp/terraform-provider-aws/internal/errs"
	"github.com/hashicorp/terraform-provider-aws/internal/framework"
	"github.com/hashicorp/terraform-provider-aws/internal/framework/flex"
	fwtypes "github.com/hashicorp/terraform-provider-aws/internal/framework/types"
	tftags "github.com/hashicorp/terraform-provider-aws/internal/tags"
	"github.com/hashicorp/terraform-provider-aws/internal/tfresource"
	"github.com/hashicorp/terraform-provider-aws/names"
)

const (
	ResNameRotation = "Rotation"
)

// @FrameworkResource(name="Rotation")
// @Tags(identifierAttribute="arn")
func newResourceRotation(context.Context) (resource.ResourceWithConfigure, error) {
	r := &resourceRotation{}

	return r, nil
}

type resourceRotation struct {
	framework.ResourceWithConfigure
}

func (r *resourceRotation) Metadata(_ context.Context, request resource.MetadataRequest, response *resource.MetadataResponse) {
	response.TypeName = "aws_ssmcontacts_rotation"
}

// Schema returns the schema for this resource.
func (r *resourceRotation) Schema(ctx context.Context, request resource.SchemaRequest, response *resource.SchemaResponse) {
	s := schema.Schema{
		Attributes: map[string]schema.Attribute{
			"arn": framework.ARNAttributeComputedOnly(),
			"contact_ids": schema.ListAttribute{
				CustomType:  fwtypes.ListOfStringType,
				ElementType: types.StringType,
				Required:    true,
			},
			"id": framework.IDAttribute(),
			"name": schema.StringAttribute{
				Required: true,
			},
			"start_time": schema.StringAttribute{
				CustomType: fwtypes.TimestampType,
				Optional:   true,
			},
			names.AttrTags:    tftags.TagsAttribute(),
			names.AttrTagsAll: tftags.TagsAttributeComputedOnly(),
			"time_zone_id": schema.StringAttribute{
				Required: true,
			},
		},
		Blocks: map[string]schema.Block{
			"recurrence": schema.ListNestedBlock{
				CustomType: fwtypes.NewListNestedObjectTypeOf[recurrenceData](ctx),
				Validators: []validator.List{
					listvalidator.IsRequired(),
					listvalidator.SizeAtMost(1),
				},
				NestedObject: schema.NestedBlockObject{
					Attributes: map[string]schema.Attribute{
						"number_of_on_calls": schema.Int64Attribute{
							Required: true,
						},
						"recurrence_multiplier": schema.Int64Attribute{
							Required: true,
						},
					},
					Blocks: map[string]schema.Block{
						"daily_settings": handOffTimeSchema(ctx, nil),
						"monthly_settings": schema.ListNestedBlock{
							CustomType: fwtypes.NewListNestedObjectTypeOf[monthlySettingsData](ctx),
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"day_of_month": schema.Int64Attribute{
										Required: true,
									},
								},
								Blocks: map[string]schema.Block{
									"hand_off_time": handOffTimeSchema(ctx, aws.Int(1)),
								},
							},
						},
						"shift_coverages": schema.ListNestedBlock{
							CustomType: fwtypes.NewListNestedObjectTypeOf[shiftCoveragesData](ctx),
							PlanModifiers: []planmodifier.List{
								ShiftCoveragesPlanModifier(),
								listplanmodifier.UseStateForUnknown(),
							},
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"map_block_key": schema.StringAttribute{
										CustomType: fwtypes.StringEnumType[awstypes.DayOfWeek](),
										Required:   true,
									},
								},
								Blocks: map[string]schema.Block{
									"coverage_times": schema.ListNestedBlock{
										CustomType: fwtypes.NewListNestedObjectTypeOf[coverageTimesData](ctx),
										NestedObject: schema.NestedBlockObject{
											Blocks: map[string]schema.Block{
												"end":   handOffTimeSchema(ctx, aws.Int(1)),
												"start": handOffTimeSchema(ctx, aws.Int(1)),
											},
										},
										Validators: []validator.List{
											listvalidator.IsRequired(),
											listvalidator.SizeAtLeast(1),
										},
									},
								},
							},
						},
						"weekly_settings": schema.ListNestedBlock{
							CustomType: fwtypes.NewListNestedObjectTypeOf[weeklySettingsData](ctx),
							NestedObject: schema.NestedBlockObject{
								Attributes: map[string]schema.Attribute{
									"day_of_week": schema.StringAttribute{
										CustomType: fwtypes.StringEnumType[awstypes.DayOfWeek](),
										Required:   true,
									},
								},
								Blocks: map[string]schema.Block{
									"hand_off_time": handOffTimeSchema(ctx, aws.Int(1)),
								},
							},
						},
					},
				},
			},
		},
	}

	if s.Blocks == nil {
		s.Blocks = make(map[string]schema.Block)
	}

	response.Schema = s
}

func handOffTimeSchema(ctx context.Context, size *int) schema.ListNestedBlock {
	listSchema := schema.ListNestedBlock{
		CustomType: fwtypes.NewListNestedObjectTypeOf[handOffTime](ctx),
		NestedObject: schema.NestedBlockObject{
			Attributes: map[string]schema.Attribute{
				"hour_of_day": schema.Int64Attribute{
					Required: true,
				},
				"minute_of_hour": schema.Int64Attribute{
					Required: true,
				},
			},
		},
	}

	if size != nil {
		listSchema.Validators = []validator.List{
			listvalidator.SizeAtMost(*size),
		}
	}

	return listSchema
}

func (r *resourceRotation) Create(ctx context.Context, request resource.CreateRequest, response *resource.CreateResponse) {
	conn := r.Meta().SSMContactsClient(ctx)
	var plan resourceRotationData

	response.Diagnostics.Append(request.Plan.Get(ctx, &plan)...)

	if response.Diagnostics.HasError() {
		return
	}
	input := &ssmcontacts.CreateRotationInput{}
	response.Diagnostics.Append(flex.Expand(ctx, plan, input)...)

	if response.Diagnostics.HasError() {
		return
	}

	sc := newShiftCoverages()
	response.Diagnostics.Append(sc.expand(ctx, &plan)...)

	if response.Diagnostics.HasError() {
		return
	}

	input.Recurrence.ShiftCoverages = sc
	input.Tags = getTagsIn(ctx)

	output, err := conn.CreateRotation(ctx, input)

	if err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.SSMContacts, create.ErrActionCreating, ResNameRotation, plan.Name.ValueString(), err),
			err.Error(),
		)
		return
	}

	state := plan

	response.Diagnostics.Append(flex.Flatten(ctx, output, &state)...)

	state.ID = flex.StringToFramework(ctx, output.RotationArn)
	state.ARN = flex.StringToFramework(ctx, output.RotationArn)

	response.Diagnostics.Append(response.State.Set(ctx, &state)...)
}

// Read is called when the provider must read resource values in order to update state.
// Planned state values should be read from the ReadRequest and new state values set on the ReadResponse.
func (r *resourceRotation) Read(ctx context.Context, request resource.ReadRequest, response *resource.ReadResponse) {
	conn := r.Meta().SSMContactsClient(ctx)
	var state resourceRotationData

	response.Diagnostics.Append(request.State.Get(ctx, &state)...)

	if response.Diagnostics.HasError() {
		return
	}

	output, err := FindRotationByID(ctx, conn, state.ID.ValueString())

	if tfresource.NotFound(err) {
		response.State.RemoveResource(ctx)
		return
	}

	if err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.SSMContacts, create.ErrActionSetting, ResNameRotation, state.ID.ValueString(), err),
			err.Error(),
		)
		return
	}

	response.Diagnostics.Append(flex.Flatten(ctx, output, &state)...)

	if response.Diagnostics.HasError() {
		return
	}

	response.Diagnostics.Append(response.State.Set(ctx, &state)...)
}

func (r *resourceRotation) Update(ctx context.Context, request resource.UpdateRequest, response *resource.UpdateResponse) {
	var plan resourceRotationData

	//response.Diagnostics.Append(request.State.Get(ctx, &old)...)
	//
	//if response.Diagnostics.HasError() {
	//	return
	//}
	//
	response.Diagnostics.Append(request.Plan.Get(ctx, &plan)...)

	if response.Diagnostics.HasError() {
		return
	}
	//updateTimeout := r.UpdateTimeout(ctx, new.Timeouts)

	response.Diagnostics.Append(response.State.Set(ctx, &plan)...)
}

func (r *resourceRotation) Delete(ctx context.Context, request resource.DeleteRequest, response *resource.DeleteResponse) {
	conn := r.Meta().SSMContactsClient(ctx)
	var state resourceRotationData

	response.Diagnostics.Append(request.State.Get(ctx, &state)...)

	if response.Diagnostics.HasError() {
		return
	}

	tflog.Debug(ctx, "deleting TODO", map[string]interface{}{
		"id": state.ID.ValueString(),
	})

	_, err := conn.DeleteRotation(ctx, &ssmcontacts.DeleteRotationInput{
		RotationId: flex.StringFromFramework(ctx, state.ID),
	})

	if errs.IsA[*awstypes.ResourceNotFoundException](err) {
		return
	}

	if err != nil {
		response.Diagnostics.AddError(
			create.ProblemStandardMessage(names.SSMContacts, create.ErrActionDeleting, ResNameRotation, state.ID.ValueString(), err),
			err.Error(),
		)
		return
	}
}

func (r *resourceRotation) ImportState(ctx context.Context, request resource.ImportStateRequest, response *resource.ImportStateResponse) {
	resource.ImportStatePassthroughID(ctx, path.Root("id"), request, response)
}

func (r *resourceRotation) ModifyPlan(ctx context.Context, request resource.ModifyPlanRequest, response *resource.ModifyPlanResponse) {
	r.SetTagsAll(ctx, request, response)
}

type resourceRotationData struct {
	ARN        types.String                                    `tfsdk:"arn"`
	ContactIds fwtypes.ListValueOf[types.String]               `tfsdk:"contact_ids"`
	ID         types.String                                    `tfsdk:"id"`
	Recurrence fwtypes.ListNestedObjectValueOf[recurrenceData] `tfsdk:"recurrence"`
	Name       types.String                                    `tfsdk:"name"`
	StartTime  fwtypes.Timestamp                               `tfsdk:"start_time"`
	Tags       types.Map                                       `tfsdk:"tags"`
	TagsAll    types.Map                                       `tfsdk:"tags_all"`
	TimeZoneID types.String                                    `tfsdk:"time_zone_id"`
}

type recurrenceData struct {
	DailySettings        fwtypes.ListNestedObjectValueOf[handOffTime]         `tfsdk:"daily_settings"`
	MonthlySettings      fwtypes.ListNestedObjectValueOf[monthlySettingsData] `tfsdk:"monthly_settings"`
	NumberOfOnCalls      types.Int64                                          `tfsdk:"number_of_on_calls"`
	RecurrenceMultiplier types.Int64                                          `tfsdk:"recurrence_multiplier"`
	ShiftCoverages       fwtypes.ListNestedObjectValueOf[shiftCoveragesData]  `tfsdk:"shift_coverages"`
	WeeklySettings       fwtypes.ListNestedObjectValueOf[weeklySettingsData]  `tfsdk:"weekly_settings"`
}

type monthlySettingsData struct {
	DayOfMonth  types.Int64                                  `tfsdk:"day_of_month"`
	HandOffTime fwtypes.ListNestedObjectValueOf[handOffTime] `tfsdk:"hand_off_time"`
}

type shiftCoveragesData struct {
	CoverageTimes fwtypes.ListNestedObjectValueOf[coverageTimesData] `tfsdk:"coverage_times"`
	MapBlockKey   fwtypes.StringEnum[awstypes.DayOfWeek]             `tfsdk:"map_block_key"`
}

type coverageTimesData struct {
	End   fwtypes.ListNestedObjectValueOf[handOffTime] `tfsdk:"end"`
	Start fwtypes.ListNestedObjectValueOf[handOffTime] `tfsdk:"start"`
}

type handOffTime struct {
	HourOfDay    types.Int64 `tfsdk:"hour_of_day"`
	MinuteOfHour types.Int64 `tfsdk:"minute_of_hour"`
}

type weeklySettingsData struct {
	DayOfWeek   fwtypes.StringEnum[awstypes.DayOfWeek] `tfsdk:"day_of_week"`
	HandOffTime types.String                           `tfsdk:"hand_off_time"`
}

type shiftCoverages map[string][]awstypes.CoverageTime

func newShiftCoverages() shiftCoverages {
	sc := make(shiftCoverages)
	return sc
}

func (s shiftCoverages) expand(ctx context.Context, data *resourceRotationData) diag.Diagnostics {
	var diags diag.Diagnostics

	var recurrence []recurrenceData
	diags.Append(data.Recurrence.ElementsAs(ctx, &recurrence, false)...)

	if diags.HasError() {
		return diags
	}

	var sc []shiftCoveragesData
	diags.Append(recurrence[0].ShiftCoverages.ElementsAs(ctx, &sc, false)...)

	for _, v := range sc {
		var ct coverageTimes
		diags.Append(v.CoverageTimes.ElementsAs(ctx, &ct, false)...)

		if diags.HasError() {
			return diags
		}

		s[v.MapBlockKey.ValueString()] = ct.expand(ctx, diags)

	}

	return diags
}

type coverageTimes []coverageTimesData

func (c coverageTimes) expand(ctx context.Context, diags diag.Diagnostics) (result []awstypes.CoverageTime) {
	for _, v := range c {
		var start, end []handOffTime
		diags.Append(v.End.ElementsAs(ctx, &end, false)...)
		diags.Append(v.End.ElementsAs(ctx, &start, false)...)

		result = append(result, awstypes.CoverageTime{
			End: &awstypes.HandOffTime{
				HourOfDay:    flex.Int32ValueFromFramework(ctx, end[0].HourOfDay),
				MinuteOfHour: flex.Int32ValueFromFramework(ctx, end[0].MinuteOfHour),
			},
			Start: &awstypes.HandOffTime{
				HourOfDay:    flex.Int32ValueFromFramework(ctx, start[0].HourOfDay),
				MinuteOfHour: flex.Int32ValueFromFramework(ctx, start[0].MinuteOfHour),
			},
		})
	}
	return
}
